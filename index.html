<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Erial&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Erial&#039;s Blog"><meta name="msapplication-TileImage" content="/img/Tabicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Erial&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Erial&#039;s Blog"><meta property="og:url" content="https://erial21.github.io/"><meta property="og:site_name" content="Erial&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://erial21.github.io/img/og_image.png"><meta property="article:author" content="Erial"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://erial21.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://erial21.github.io"},"headline":"Erial's Blog","image":["https://erial21.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Erial"},"publisher":{"@type":"Organization","name":"Erial's Blog","logo":{"@type":"ImageObject","url":"https://erial21.github.io/img/ERIAL.png"}},"description":""}</script><link rel="icon" href="/img/Tabicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/ERIAL.png" alt="Erial&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Erial21"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-09T09:33:52.000Z" title="2023/2/9 17:33:52">2023-02-09</time>发表</span><span class="level-item"><time dateTime="2023-02-16T08:42:50.261Z" title="2023/2/16 16:42:50">2023-02-16</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/Hexo-Blog/">Hexo Blog</a></span><span class="level-item">2 分钟读完 (大约252个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/09/Hexo/Icarus%E5%AE%89%E8%A3%85/">Icarus安装</a></h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面的文章，已经学习了 Hexo 博客的安装和基本操作。本篇将解决主题的安装问题。</p>
<p>Hexo 有不少的主题可以挑选，官网的 <a target="_blank" rel="noopener" href="https://hexo.io/themes/">主题页面</a> 有 300+ 的主题可供选择。</p></div><a class="article-more button is-small is-size-7" href="/2023/02/09/Hexo/Icarus%E5%AE%89%E8%A3%85/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-02-06T12:23:50.000Z" title="2023/2/6 20:23:50">2023-02-06</time>发表</span><span class="level-item"><time dateTime="2023-02-16T08:42:49.030Z" title="2023/2/16 16:42:49">2023-02-16</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/Hexo-Blog/">Hexo Blog</a></span><span class="level-item">5 分钟读完 (大约788个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/02/06/Hexo/Hexo%E5%AE%89%E8%A3%85/">Hexo安装</a></h1><div class="content"><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用  <a target="_blank" rel="noopener" href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></div><a class="article-more button is-small is-size-7" href="/2023/02/06/Hexo/Hexo%E5%AE%89%E8%A3%85/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-10-17T16:55:45.000Z" title="2022/10/18 00:55:45">2022-10-18</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:16:20.595Z" title="2023/2/17 00:16:20">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">12 分钟读完 (大约1742个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/10/18/CPP/C++%2011/">C++ 11</a></h1><div class="content"><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><ul>
<li>使用 auto 必须初始化；</li>
<li>auto 根据初始化的值来推导数据类型；</li>
<li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li>
<li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li>
</ul>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ol>
<li>不能再函数参数中使用</li>
<li>不能作用于类的非静态成员变量（没有 static 关键字的变量）</li>
<li>不能定义数组；</li>
<li>不能用于模板参数</li>
</ol>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>迭代器</li>
<li>泛型编程</li>
</ul>
<hr>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>“declare type”的缩写。</p>
<p>和 auto 相似，用于自动的类型推导。</p>
<p><code>decltype(exp) varname = value;</code><br>根据 exp 推出类型，而不是 <code>value</code> 。</p>
<p>不要求变量初始化。</p>
<h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><ul>
<li><code>exp</code> 是变量，则类型为变量</li>
<li><code>exp</code> 是函数，则类型为函数返回类型</li>
<li><code>exp</code> 是左值，则类型为 <code>exp</code> 的引用</li>
</ul>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><ul>
<li>非静态成员</li>
</ul>
<h2 id="auto-和-decltype-区别"><a href="#auto-和-decltype-区别" class="headerlink" title="auto 和 decltype 区别"></a>auto 和 decltype 区别</h2><ul>
<li>auto 可能不保留 const 等限定符，decltype 则会保留。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非指针非引用类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="number">10</span>;</span><br><span class="line">n2 = <span class="number">99</span>;  <span class="comment">//赋值不报错</span></span><br><span class="line"><span class="keyword">decltype</span>(n1) n3 = <span class="number">20</span>;</span><br><span class="line">n3 = <span class="number">5</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;n1;</span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br><span class="line">*p2 = <span class="number">66</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"><span class="keyword">decltype</span>(p1) p3 = p1;</span><br><span class="line">*p3 = <span class="number">19</span>;  <span class="comment">//赋值报错</span></span><br></pre></td></tr></table></figure>

<h4 id="对引用的处理"><a href="#对引用的处理" class="headerlink" title="对引用的处理"></a>对引用的处理</h4><ul>
<li>auto 抛弃引用类型，decltype 保留引用类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r1 = n;</span><br><span class="line">    std::cout &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; &amp;r1 &lt;&lt; std::endl; <span class="comment">// 10, 0x61fe04</span></span><br><span class="line">    std::cout &lt;&lt; &amp;n &lt;&lt; std::endl; <span class="comment">// 0x61fe04</span></span><br><span class="line">    <span class="comment">// auto推导</span></span><br><span class="line">    <span class="keyword">auto</span> r2 = r1;</span><br><span class="line">    r2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// decltype推导</span></span><br><span class="line">    <span class="keyword">decltype</span>(r1) r3 = n;</span><br><span class="line">    std::cout &lt;&lt; &amp;r3 &lt;&lt; std::endl; <span class="comment">//0x61fe04</span></span><br><span class="line">    r3 = <span class="number">99</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="CPP/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF">深入理解模板</a></p>
<hr>
<h2 id="返回值类型后置"><a href="#返回值类型后置" class="headerlink" title="返回值类型后置"></a>返回值类型后置</h2><hr>
<h2 id="模板实例化中-gt-gt-符号的改进"><a href="#模板实例化中-gt-gt-符号的改进" class="headerlink" title="模板实例化中&gt;&gt; 符号的改进"></a>模板实例化中&gt;&gt; 符号的改进</h2><p>在 C++ 98&#x2F;03 中，&gt;&gt;符号通常被编译器解释为右移操作符，通常会提示在两个尖括号中间添加空格。</p>
<p>现在 C++ 11 对模板的 &gt;&gt; 符号进行了单独处理，不再出问题。</p>
<p>当然在需要右移操作符时，最好用括号将表达式括起来。</p>
<hr>
<h2 id="使用-using-代替-typedef-定义别名"><a href="#使用-using-代替-typedef-定义别名" class="headerlink" title="使用 using 代替 typedef 定义别名"></a>使用 using 代替 typedef 定义别名</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>

<ul>
<li>typedef 具有语法一致性，但遇到复杂的会降低可读性</li>
<li>using 直接在后面用赋值的方式，更清晰</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br></pre></td></tr></table></figure>

<p>使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98&#x2F;03 那样使用烦琐的外敷模板。</p>
<hr>
<h2 id="支持函数模板的默认模板参数"><a href="#支持函数模板的默认模板参数" class="headerlink" title="支持函数模板的默认模板参数"></a>支持函数模板的默认模板参数</h2><hr>
<h2 id="在函数模板和类模板中使用可变参数"><a href="#在函数模板和类模板中使用可变参数" class="headerlink" title="在函数模板和类模板中使用可变参数"></a>在函数模板和类模板中使用可变参数</h2><h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><hr>
<h2 id="tuple-元组详解"><a href="#tuple-元组详解" class="headerlink" title="tuple 元组详解"></a>tuple 元组详解</h2><hr>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><hr>
<h2 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h2><p><a href="../CPP/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">Lambda 表达式</a></p>
<hr>
<h2 id="非受限联合体（union）"><a href="#非受限联合体（union）" class="headerlink" title="非受限联合体（union）"></a>非受限联合体（union）</h2><h3 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h3><p>POD 类型一般具有以下几种特征（包括 class、union 和 struct 等）：</p>
<ol>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为 public。</li>
<li>类中的第一个非静态成员的类型与其基类不同，例如：</li>
</ol>
<p>class B1{};<br>class B2 : B1 {B1 b;};</p>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p>
<ol start="5">
<li>在类或者结构体继承时，满足以下两种情况之一：</li>
</ol>
<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
<ol start="6">
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</li>
<li>此外，所有兼容 C 语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</li>
</ol>
<h3 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h3><h3 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h3><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<p>这条规则可能导致对象构造失败。</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s; <span class="comment">// string有自己的构造函数</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决问题要用到 <code>placement new</code> ，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p>语法：<br><code>new(address) ClassConstruct(…)</code></p>
<ul>
<li>address 是内存地址。</li>
<li>ClassConstruct 表调用类的构造函数，如没有可省略括号</li>
</ul>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h3 id="非受限联合体的匿名声明和-“枚举式类”"><a href="#非受限联合体的匿名声明和-“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和 “枚举式类”"></a>非受限联合体的匿名声明和 “枚举式类”</h3><hr>
<h2 id="for-循环（基于范围的循环）详解"><a href="#for-循环（基于范围的循环）详解" class="headerlink" title="for 循环（基于范围的循环）详解"></a>for 循环（基于范围的循环）详解</h2><p>C++ 11 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123;</span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : arc) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>不管是遍历什么，即使是遍历容器，也不是遍历指向各个元素的迭代器，而是容器中的各个元素。</li>
<li>用范围的方式还可以遍历<strong>字符串</strong></li>
<li>不支持遍历指针形式返回的数组（需要范围明确）</li>
<li>遍历 string 或容器时，遍历过程中函数只执行一次，如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str= <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retStr:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历函数返回的 string 字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// output:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// retStr:</span></span><br><span class="line">	<span class="comment">//http://c.biancheng.net/cplus/11/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用基于范围的循环时，不修改容器中不允许被修改的部分</li>
<li>基于范围的循环，其底层也是借助容器迭代器实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">//向容器中添加元素</span></span><br><span class="line">        <span class="comment">// 添加元素致使迭代器失效</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">	<span class="comment">//-572662307</span></span><br><span class="line">	<span class="comment">//-572662307</span></span><br><span class="line">	<span class="comment">//4</span></span><br><span class="line">	<span class="comment">//5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="long-long-超长整型"><a href="#long-long-超长整型" class="headerlink" title="long long 超长整型"></a>long long 超长整型</h2><hr>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a><a href="CPP/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">右值引用</a></h2><hr>
<h2 id="移动构造函数的功能和用法"><a href="#移动构造函数的功能和用法" class="headerlink" title="移动构造函数的功能和用法"></a>移动构造函数的功能和用法</h2><hr>
<h2 id="move-函数"><a href="#move-函数" class="headerlink" title="move() 函数"></a>move() 函数</h2><hr>
<h2 id="引用限定符"><a href="#引用限定符" class="headerlink" title="引用限定符"></a>引用限定符</h2><hr>
<h2 id="完美转发及其实现"><a href="#完美转发及其实现" class="headerlink" title="完美转发及其实现"></a>完美转发及其实现</h2><hr>
<h2 id="nullptr-初始化空指针"><a href="#nullptr-初始化空指针" class="headerlink" title="nullptr 初始化空指针"></a>nullptr 初始化空指针</h2><hr>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a><a href="CPP/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B9%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">智能指针</a></h2><hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-21T16:33:22.000Z" title="2022/9/22 00:33:22">2022-09-22</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:16:28.619Z" title="2023/2/17 00:16:28">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">3 分钟读完 (大约406个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/22/CPP/static%E5%85%B3%E9%94%AE%E5%AD%97/">static关键字</a></h1><div class="content"><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>static 声明全局变量，不改变全局变量的存储位置与生命周期，仅改变全局变量的作用域，不被其他源文件通过 extern 调用。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>static 会将局部变量的存储位置更改为静态存储区，生命周期伴随程序运行的整个过程。</p>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>普通函数不是类成员函数，使用 static 声明将限制函数的作用域，不被其他源文件通过 extern 调用；static 声明的函数在内存中仅存储一份拷贝。</p>
<h4 id="一些优点："><a href="#一些优点：" class="headerlink" title="一些优点："></a>一些优点：</h4><ol>
<li>避免了链接不同源文件时，发生变量名和函数名的冲突。</li>
<li>对 c 函数而言，对函数进行了信息屏蔽，只给当前文件的一些函数使用。</li>
</ol>
<h3 id="类-static-成员"><a href="#类-static-成员" class="headerlink" title="类 static 成员"></a>类 static 成员</h3><p><strong>static 使成员由”属于类对象“变为”属于类，不属于类对象“</strong></p>
<h4 id="数据成员"><a href="#数据成员" class="headerlink" title="数据成员"></a>数据成员</h4><ol>
<li>static 的数据成员需要在类定义体外部进行定义</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BOOK</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//折扣</span></span><br><span class="line">        <span class="type">static</span> <span class="type">float</span> discount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类定义体外部定义并初始化</span></span><br><span class="line"><span class="type">float</span> BOOK::discount = <span class="number">0.95f</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>例外</strong>，当使用<code>const static</code>时，可以在类定义体内初始化数据成员，但仍需要在类定义体外进行一次定义。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BOOK</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//折扣</span></span><br><span class="line">        <span class="type">const</span> <span class="type">static</span>  <span class="type">int</span>  discount=<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> BOOK::discount;</span><br></pre></td></tr></table></figure>

<h4 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h4><p>在类内部声明的 static 成员函数，在类定义体外部不需要重复指定 static 关键字。</p>
<p>static 成员函数不能被声明为 const。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-20T16:34:32.000Z" title="2022/9/21 00:34:32">2022-09-21</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:16:24.267Z" title="2023/2/17 00:16:24">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">4 分钟读完 (大约582个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/21/CPP/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Lambda表达式</a></h1><div class="content"><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>能够捕获<em>作用域</em>中的变量的无名函数对象。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (parameters) mutable -&gt; return-type &#123;statement&#125;</span><br></pre></td></tr></table></figure>

<h3 id="capture-捕获"><a href="#capture-捕获" class="headerlink" title="capture 捕获"></a>capture 捕获</h3><p>capture 部分指定哪些变量被捕获，以及是值捕获还是引用捕获。空的 capture 子句 [] 只是 lambda 表达式的主体不访问封闭范围中的变量。</p>
<p>可使用默认捕获模式：**&amp;** 表示所有变量都通过引用的方式捕获；**&#x3D;** 表示所有变量都通过值的方式捕获。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="keyword">auto</span> f = []() &#123; <span class="keyword">return</span> a * <span class="number">9</span>; &#125;; <span class="comment">// Error, 无法访问 &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> f = [a]() &#123; <span class="keyword">return</span> a * <span class="number">9</span>; &#125;; <span class="comment">// OK, &#x27;a&#x27; 被值“捕获”</span></span><br><span class="line"><span class="keyword">auto</span> f = [&amp;a]() &#123; <span class="keyword">return</span> a++; &#125;; <span class="comment">// OK, &#x27;a&#x27; 被引用“捕获”</span></span><br><span class="line">                                <span class="comment">// 注意：请保证 Lambda 被调用时 a 没有被销毁</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">f</span>(); <span class="comment">// f 从捕获列表里获得 a 的值，无需通过参数传入 a</span></span><br></pre></td></tr></table></figure>

<p>调用 lambda 表达式时，不需要在传递参数了，因为可以由 lambda 表达式捕获，如上 <code>auto b = f()</code> 代码。</p>
<h3 id="parameters-参数列表"><a href="#parameters-参数列表" class="headerlink" title="parameters 参数列表"></a>parameters 参数列表</h3><p>大多数情况下类似函数参数列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lam = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">lam</span>(<span class="number">1</span>, <span class="number">9</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">lam</span>(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>parameters 参数列表</strong> 是可选的，如果不将参数传递给 Lambda 表达式，并且其 Lambda 声明器不包含 mutable，且没有后置返回值类型，则可以 <strong>省略空括号</strong> 。</p>
<p>参数列表可以用另外一个 lambda 表达式嵌套使用。</p>
<h3 id="mutable-可变规范"><a href="#mutable-可变规范" class="headerlink" title="mutable 可变规范"></a>mutable 可变规范</h3><p>利用可变规范，Lambda 表达式的主体可以修改通过值捕获的变量。若使用此关键字，则 parameters <strong>不可省略</strong>（即使为空）。</p>
<p>一个例子，使用  <strong>capture 捕获字句</strong>  中的例子，来观察 a 的值的变化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [a]() <span class="keyword">mutable</span> &#123; ++a; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="return-type-返回类型"><a href="#return-type-返回类型" class="headerlink" title="return-type 返回类型"></a>return-type 返回类型</h3><p>指定 lambda 表达式的返回类型，如果没有，将会自动推断。</p>
<h3 id="statement-lambda-主题"><a href="#statement-lambda-主题" class="headerlink" title="statement lambda 主题"></a>statement lambda 主题</h3><p>和普通的函数体差不多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">	[&amp;, n](<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; m = (++n) + a; &#125;(<span class="number">4</span>);</span><br><span class="line">	std::cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们得到输出  <code>5 0</code>。这是由于  <code>n</code>  是通过值捕获的，在调用 Lambda 表达式后仍保持原来的值  <code>0</code>  不变。<code>mutable</code>  规范允许  <code>n</code>  在 Lambda 主体中被修改，将  <code>mutable</code>  删去则编译不通过。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-19T16:43:57.000Z" title="2022/9/20 00:43:57">2022-09-20</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:16:12.528Z" title="2023/2/17 00:16:12">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">6 分钟读完 (大约855个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/20/CPP/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">右值引用</a></h1><div class="content"><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>左值可以被看作一个具有名称的内存位置。</p>
<h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ul>
<li>能被取地址运算符获取地址</li>
<li>可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数</li>
<li>可用来初始化左值引用</li>
</ul>
<h3 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h3><p>相当于 C++ 11 之前的右值。</p>
<h3 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h3><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><em>引用</em> 本质是别名，通过引用修改变量的值，传参时避免拷贝。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用的标志为 <code>&amp;&amp;</code> ，只能指向右值，不能指向左值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"></span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure>

<h3 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h3><h4 id="1-右值引用指向左值"><a href="#1-右值引用指向左值" class="headerlink" title="1. 右值引用指向左值"></a>1. 右值引用指向左值</h4><p>使用 <code>std::move</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;ref_a_right = std::<span class="built_in">move</span>(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure>

<p><code>std::move</code> 的功能就是强制把左值转换为右值，实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp; &gt;(lvalue)</code> 。</p>
<h4 id="2-左值引用、右值引用是什么值"><a href="#2-左值引用、右值引用是什么值" class="headerlink" title="2. 左值引用、右值引用是什么值"></a>2. 左值引用、右值引用是什么值</h4><p>声明的 <em>左值引用</em> 和 <em>右值引用</em> 都是 <strong>左值</strong> 。</p>
<h3 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 T&amp;&amp; param 的方式，传入左值引用或右值引用，可推导绑定左值或右值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">2019</span>;</span><br><span class="line"><span class="built_in">func</span>(num);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">2019</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>一个模板函数，根据定义的形参和传入的实参的类型，我们可以有下面四中组合：</p>
<ul>
<li>左值-左值 T&amp; &amp; # 函数定义的形参类型是左值引用，传入的实参是左值引用</li>
<li>左值-右值 T&amp; &amp;&amp; # 函数定义的形参类型是左值引用，传入的实参是右值引用</li>
<li>右值-左值 T&amp;&amp; &amp; # 函数定义的形参类型是右值引用，传入的实参是左值引用</li>
<li>右值-右值 T&amp;&amp; &amp;&amp; # 函数定义的形参类型是右值引用，传入的实参是右值引用</li>
</ul>
<p>但是 C++中不允许对引用再进行引用，对于上述情况的处理有如下的规则：</p>
<p>所有的折叠引用最终都代表一个引用，要么是左值引用，要么是右值引用。规则是：<strong>如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用</strong>。</p>
<p>所以最后结果是：</p>
<ul>
<li>T&amp; &amp; &#x3D; &amp;</li>
<li>T&amp; &amp;&amp; &#x3D; &amp;</li>
<li>T&amp;&amp; &amp; &#x3D; &amp;</li>
<li>T&amp;&amp; &amp;&amp; &#x3D; &amp;&amp;</li>
</ul>
<p>当且仅当函数形参为右值引用且传入参数也为右值引用时，最终折叠后为<strong>右值引用</strong></p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>使用 <code>std::forward</code> 进行完美转发，<code>std::forward</code> 能够将正确的引用类型转发。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>在进行对象的复制时，可能有两种需求：一种是深拷贝，开辟新的内存空间，拷贝原对象到这个新的内存空间；另一种则是通过右值引用，将原对象的成员通过修改标记的方式重新由新对象的成员指向，然后将原对象的所有成员清空。</p>
<p>调用赋值运算符时，也同理。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-18T16:55:11.000Z" title="2022/9/19 00:55:11">2022-09-19</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:16:05.768Z" title="2023/2/17 00:16:05">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">2 分钟读完 (大约368个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/19/CPP/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/">虚函数和纯虚函数</a></h1><div class="content"><h1 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p>类中，声明函数前有<code>virtual</code>关键字的为虚函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">example</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>纯虚函数的声明格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">example</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">intro</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;I am a funtion of class A.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">intro</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;I am a funtion of class B.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">intro</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;I am a funtion of class C.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="comment">//! 调用A::intro()</span></span><br><span class="line">    a-&gt;<span class="built_in">intro</span>();</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">B</span>());</span><br><span class="line">    <span class="comment">//! 调用B::intro()</span></span><br><span class="line">    a-&gt;<span class="built_in">intro</span>();</span><br><span class="line"></span><br><span class="line">	a.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">C</span>());</span><br><span class="line">    <span class="comment">//! 调用C::intro()</span></span><br><span class="line">    a-&gt;<span class="built_in">intro</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数重写和函数重载"><a href="#函数重写和函数重载" class="headerlink" title="函数重写和函数重载"></a>函数重写和函数重载</h2><h3 id="函数重写（override）"><a href="#函数重写（override）" class="headerlink" title="函数重写（override）"></a>函数重写（override）</h3><p>派生类中重新定义函数，只有函数体中实现的内容可以和被重写的函数不同。</p>
<p>基类被重写的函数应该是<em>虚函数或纯虚函数</em>。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数同名，但参数的<em>个数</em>，<em>类型_，_顺序</em> 可以不同，调用时根据参数列表选择函数。</p>
<p>重载不关心函数返回类型。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">intro</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;I am a funtion of class A.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">intro</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;I am a funtion of class B.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">intro</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;I am a funtion of class B with input param int.&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="comment">//! 调用A::intro()</span></span><br><span class="line">    a-&gt;<span class="built_in">intro</span>();</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">B</span>());</span><br><span class="line">    <span class="comment">//! 调用B::intro()， B::intro()重写了A::intro()</span></span><br><span class="line">    a-&gt;<span class="built_in">intro</span>();</span><br><span class="line"></span><br><span class="line">	B b;</span><br><span class="line">    <span class="comment">//! 调用B::intro(int a)， B::intro(int a)重载了B::intro()</span></span><br><span class="line">    b.<span class="built_in">intro</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-18T16:17:16.000Z" title="2022/9/19 00:17:16">2022-09-19</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:16:00.845Z" title="2023/2/17 00:16:00">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">6 分钟读完 (大约866个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/19/CPP/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF/">深入理解模板</a></h1><div class="content"><p>模板是泛型编程的实现方式之一，只需要写一份便可以套用不同类型的类、函数、变量。</p>
<p><strong>（以下涉及的代码有部分是从<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_64361907/article/details/126788130">https://blog.csdn.net/m0_64361907/article/details/126788130</a> 处转载）</strong></p>
<h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><h4 id="这是普通的-c-语言写交换函数"><a href="#这是普通的-c-语言写交换函数" class="headerlink" title="这是普通的 c 语言写交换函数"></a>这是普通的 c 语言写交换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swapi</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swapd</span><span class="params">(<span class="type">double</span>* a, <span class="type">double</span>* b)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Swapi</span>(&amp;a, &amp;b);</span><br><span class="line">	<span class="type">double</span> c = <span class="number">1.1</span>, d = <span class="number">2.2</span>;</span><br><span class="line">	<span class="built_in">Swapd</span>(&amp;c, &amp;d);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，对于不同的参数类型，我们要写多个不同的交换函数。</p>
<p>而在 c 语言中，是不支持函数重载的，所以不同的交换函数无法使用同样的函数名实现重载</p>
<h4 id="c-写交换函数"><a href="#c-写交换函数" class="headerlink" title="c++写交换函数"></a>c++写交换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">double</span>&amp; x, <span class="type">double</span>&amp; y)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> c = <span class="number">1.1</span>, d = <span class="number">2.2</span>;</span><br><span class="line">	<span class="built_in">Swap</span>(c, d);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>C++ 中有了引用和函数重载，但是在实现不同类型参数的交换函数时仍然很麻烦。</p>
<p>所以就有了<strong>模板</strong></p>
<h4 id="使用模板的交换函数"><a href="#使用模板的交换函数" class="headerlink" title="使用模板的交换函数"></a>使用模板的交换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; x, T&amp; y)</span></span>&#123;</span><br><span class="line">	T tmp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">	<span class="type">double</span> c = <span class="number">1.1</span>, d = <span class="number">2.2</span>;</span><br><span class="line">	<span class="built_in">Swap</span>(c, d);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如此，编译器能够自己套用对应的参数类型。</p>
<h4 id="显示实例化和隐式实例化"><a href="#显示实例化和隐式实例化" class="headerlink" title="显示实例化和隐式实例化"></a>显示实例化和隐式实例化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; x,<span class="type">const</span> T&amp; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	<span class="type">double</span> c = <span class="number">1.1</span>, d = <span class="number">2.2</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>(a, b) &lt;&lt; endl;<span class="comment">//编译器要自己推类型的是隐式实例化</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>(c, d) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; Add(a, c) &lt;&lt; endl;//error这样的写法就错了，为难编译器了，编译器也推不出来了</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a, c) &lt;&lt; endl;<span class="comment">//不需要编译器去推的是显示实例化</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>&lt;<span class="type">double</span>&gt;(b, d) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">Add</span>(a, (<span class="type">int</span>)c) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不告诉编译器参数类型的是<em>隐式实例化</em></p>
<p>指定了参数类型的是<em>显式实例化</em></p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>此处将会以一个建议的 vector 容器的模板类实现作为例子。</p>
<h4 id="实现-vector-落后的方式"><a href="#实现-vector-落后的方式" class="headerlink" title="实现 vector 落后的方式"></a>实现 vector 落后的方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> VDateType;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//……</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	VDateType* _a;</span><br><span class="line">	<span class="type">size_t</span> _size;</span><br><span class="line">	<span class="type">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector v1;</span><br><span class="line">	vector v2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以前的实现方式是这样的，但我们不能让<code>v1</code>类型为 int，<code>v2</code>类型为 double。</p>
<h4 id="使用类模板的方式"><a href="#使用类模板的方式" class="headerlink" title="使用类模板的方式"></a>使用类模板的方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> kcc&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">vector</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">vector</span>()</span><br><span class="line">			:_a(<span class="literal">nullptr</span>)</span><br><span class="line">			, _size(<span class="number">0</span>)</span><br><span class="line">			, _capacity(<span class="number">0</span>)</span><br><span class="line">		&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 拷贝构造和operator= 这里涉及深浅拷贝问题，还挺复杂，后面具体再讲</span></span><br><span class="line"></span><br><span class="line">		~<span class="built_in">vector</span>()&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] _a;</span><br><span class="line">			_a = <span class="literal">nullptr</span>;</span><br><span class="line">			_size = _capacity = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (_size == _capacity)&#123;</span><br><span class="line">				<span class="type">int</span> newcapacity = _capacity == <span class="number">0</span> ? <span class="number">4</span> : _capacity * <span class="number">2</span>;</span><br><span class="line">				T* tmp = <span class="keyword">new</span> T[newcapacity];</span><br><span class="line">				<span class="keyword">if</span> (_a)&#123;</span><br><span class="line">					<span class="built_in">memcpy</span>(tmp, _a, <span class="built_in">sizeof</span>(T) * _size);</span><br><span class="line">					<span class="keyword">delete</span>[] _a;</span><br><span class="line">				&#125;</span><br><span class="line">				_a = tmp;</span><br><span class="line">				_capacity = newcapacity;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			_a[_size] = x;</span><br><span class="line">			++_size;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读+写</span></span><br><span class="line">		T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos);</span><br><span class="line">		<span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T* _a;</span><br><span class="line">		<span class="type">size_t</span> _size;</span><br><span class="line">		<span class="type">size_t</span> _capacity;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模板不支持分离编译，也就是声明在.h ,定义在.cpp，原因后面再讲</span></span><br><span class="line">	<span class="comment">// 建议就是定义在一个文件 xxx.h  xxx.hpp</span></span><br><span class="line">	<span class="comment">// 在类外面定义</span></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	T&amp; vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">size_t</span> pos)&#123;</span><br><span class="line">		<span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> _a[pos];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">	<span class="type">size_t</span> vector&lt;T&gt;::<span class="built_in">size</span>()&#123;</span><br><span class="line">		<span class="keyword">return</span> _size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	kcc::vector&lt;<span class="type">int</span>&gt; v1;		<span class="comment">// int</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// v1.operator[](3);</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; v1[3] &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; v1[5] &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		v1[i] *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	kcc::vector&lt;<span class="type">double</span>&gt; v2;   <span class="comment">// double</span></span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">1.1</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">2.2</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">3.3</span>);</span><br><span class="line">	v2.<span class="built_in">push_back</span>(<span class="number">4.4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">		cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-09-17T16:52:17.000Z" title="2022/9/18 00:52:17">2022-09-18</time>发表</span><span class="level-item"><time dateTime="2023-02-16T16:13:38.530Z" title="2023/2/17 00:13:38">2023-02-17</time>更新</span><span class="level-item"> Erial </span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">7 分钟读完 (大约1055个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/09/18/CPP/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B9%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">模板类之智能指针</a></h1><div class="content"><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>行为类似于指针的类对象，但还有其他功能。</p>
<p>智能指针能够帮助管理动态内存分配</p>
<p>要创建智能指针对象，必须包含头文件 <strong>memory</strong> 。</p>
<p>有三类：<code>auto_ptr</code> , <code>unique_ptr</code> , <code>shared_ptr</code> 。其中 <code>auto_ptr</code> 已经被 C++11 摒弃。</p>
<h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h2><p><strong>为什么会有三种智能指针？</strong></p>
<pre><code>三种智能指针可以处理一个问题，就是两个指针对象赋值后的内存释放问题：两个指针同时指向一个空间，那释放内存时同一块空间将被释放两次。
</code></pre>
<p><strong>三种处理方式：</strong></p>
<ul>
<li>定义运算符，进行深拷贝</li>
<li>建立所有权（ownership），只有一个指针对象能够拥有这块内存空间，赋值操作后所有权转让。这是 <code>auto_ptr</code> , <code>unique_ptr</code> 的策略</li>
<li>创建智能更高的指针，跟踪引用这个对象的智能指针数量，称为<em>引用计数（reference counting）</em> 。例如赋值时，count+1，指针过期 delete 时，count-1。这是 <code>shared_ptr</code> 的策略</li>
</ul>
<h2 id="3-unique-ptr-为何优于-auto-ptr"><a href="#3-unique-ptr-为何优于-auto-ptr" class="headerlink" title="3. unique_ptr 为何优于 auto_ptr"></a>3. unique_ptr 为何优于 auto_ptr</h2><p><code>unique_ptr</code> 会在编译阶段就报错， <code>auto_ptr</code> 则会在运行阶段使程序崩溃</p>
<p>这样一看，在编译阶段就报错的操作更好。</p>
<p><code>unique_ptr</code> 是怎么解决呢，当把一个临时右值赋给智能指针对象时，赋值操作将合法。因为临时右值将会在复制后快速被销毁，就不会造成 <em>指针悬挂</em> 。</p>
<p><code>unique_ptr</code> 还有一个有点。他有一个可用于数组的变体：</p>
<ul>
<li>delete 和 delete[] 配对</li>
<li>new 和 new[] 配对</li>
</ul>
<p>而 <code>auto_ptr</code> 则没有。</p>
<h2 id="4-如何选择"><a href="#4-如何选择" class="headerlink" title="4. 如何选择"></a>4. 如何选择</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>如果程序要使用多个指向同一个对象的指 针，应选择 shared_ptr。例子：</p>
<ul>
<li>有一个指针数组，并使用一 些辅助指针来标识特定的元素，如最大的元素和最小的元素；</li>
<li>两个对象 包含都指向第三个对象的指针；</li>
<li>STL 容器包含指针。</li>
</ul>
<p>很多 STL 算法都支 持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于 unique_ptr（编译器发出警告）和 auto_ptr（行为不确定）。如果您的编 译器没有提供 shared_ptr，可使用 Boost 库提供的 shared_ptr。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul>
<li>如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。</li>
<li>如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权将转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。</li>
<li>可将 unique_ptr 存储到 STL 容器中，只要不调用将一个 unique_ptr 复制或赋给另一个的 法或算法（如 sort( )）。</li>
</ul>
<p>在满足 unique_ptr 要求的条件时，也可使用 auto_ptr，但 unique_ptr 是 更好的选择。如果您的编译器没有提供 unique_ptr，可考虑使用 BOOST 库提供的 scoped_ptr，它与 unique_ptr 类似。</p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w;	 	<span class="comment">//创建空 weak_ptr，可以指向类型为 T 的对象</span></span><br><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">w</span><span class="params">(sp)</span></span>;	<span class="comment">//与 shared_ptr 指向相同的对象，shared_ptr 引用计数不变。T必须能转换为 sp 指向的类型</span></span><br><span class="line">w=p;				<span class="comment">//p 可以是 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象</span></span><br><span class="line">w.<span class="built_in">reset</span>();			<span class="comment">//将 w 置空</span></span><br><span class="line">w.<span class="built_in">use_count</span>();		<span class="comment">//返回与 w 共享对象的 shared_ptr 的数量</span></span><br><span class="line">w.<span class="built_in">expired</span>();		<span class="comment">//若 w.use_count() 为 0，返回 true，否则返回 false</span></span><br><span class="line">w.<span class="built_in">lock</span>();			<span class="comment">//如果 expired() 为 true，返回一个空 shared_ptr，否则返回非空 shared_ptr</span></span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">	<span class="built_in">assert</span>(sp.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line">	<span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>; 	<span class="comment">// 从 shared_ptr 创建 weak_ptr</span></span><br><span class="line">	<span class="built_in">assert</span>(wp.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (!wp.<span class="built_in">expired</span>()) &#123;	<span class="comment">// 判断 weak_ptr 观察的对象是否失效</span></span><br><span class="line">		shared_ptr&lt;<span class="type">int</span>&gt; sp2 = wp.<span class="built_in">lock</span>();	<span class="comment">// 获得一个 shared_ptr</span></span><br><span class="line">		*sp2 = <span class="number">100</span>;</span><br><span class="line">		<span class="built_in">assert</span>(wp.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(wp.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int:&quot;</span> &lt;&lt; *sp &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-06-11T08:46:40.000Z" title="2021/6/11 16:46:40">2021-06-11</time>发表</span><span class="level-item"><time dateTime="2023-02-16T08:52:48.455Z" title="2023/2/16 16:52:48">2023-02-16</time>更新</span><span class="level-item"> Erial </span><span class="level-item">4 分钟读完 (大约534个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/06/11/CUDA/cuda6/">cuda6</a></h1><div class="content"><h2 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><img src="C:\Users\Aerialith\AppData\Roaming\Typora\typora-user-images\image-20210608013044014.png" alt="image-20210608013044014"></p></div><a class="article-more button is-small is-size-7" href="/2021/06/11/CUDA/cuda6/#more">阅读更多</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/E-avatar.png" alt="Erial"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Erial</p><p class="is-size-6 is-block">求实求真，大气大为</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>福建，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Erial21" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Erial21"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/aerialith"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/albert2132/"><i class="fab fa-instagram"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Blog/"><span class="tag">Blog</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUDA/"><span class="tag">CUDA</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%8D%E4%B9%A0/"><span class="tag">复习</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B4%A0%E6%8F%8F/"><span class="tag">素描</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%98%E7%94%BB/"><span class="tag">绘画</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Hexo-Blog/"><span class="level-start"><span class="level-item">Hexo Blog</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%90%83%E5%96%9D%E7%8E%A9%E4%B9%90/"><span class="level-start"><span class="level-item">吃喝玩乐</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-09T09:33:52.000Z">2023-02-09</time></p><p class="title"><a href="/2023/02/09/Hexo/Icarus%E5%AE%89%E8%A3%85/">Icarus安装</a></p><p class="categories"><a href="/categories/Hexo-Blog/">Hexo Blog</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-06T12:23:50.000Z">2023-02-06</time></p><p class="title"><a href="/2023/02/06/Hexo/Hexo%E5%AE%89%E8%A3%85/">Hexo安装</a></p><p class="categories"><a href="/categories/Hexo-Blog/">Hexo Blog</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-17T16:55:45.000Z">2022-10-18</time></p><p class="title"><a href="/2022/10/18/CPP/C++%2011/">C++ 11</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-21T16:33:22.000Z">2022-09-22</time></p><p class="title"><a href="/2022/09/22/CPP/static%E5%85%B3%E9%94%AE%E5%AD%97/">static关键字</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-09-20T16:34:32.000Z">2022-09-21</time></p><p class="title"><a href="/2022/09/21/CPP/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Lambda表达式</a></p><p class="categories"><a href="/categories/C/">C++</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/ERIAL.png" alt="Erial&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Erial</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Erial21"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>